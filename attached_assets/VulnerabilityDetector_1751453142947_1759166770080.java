import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Detects ECDSA nonce reuse vulnerabilities in Bitcoin transactions
 * Groups signatures by R values and identifies potential attack vectors
 */
public class VulnerabilityDetector {
    
    /**
     * Groups transaction signatures by their R values
     * @param signatures List of transaction signatures
     * @return Map where keys are R values and values are lists of signatures with that R value
     */
    public Map<BigInteger, List<TransactionSignature>> groupSignaturesByR(List<TransactionSignature> signatures) {
        if (signatures == null) {
            throw new IllegalArgumentException("Signatures list cannot be null");
        }
        
        Map<BigInteger, List<TransactionSignature>> rGroups = new HashMap<>();
        
        for (TransactionSignature signature : signatures) {
            BigInteger rValue = signature.getR();
            rGroups.computeIfAbsent(rValue, k -> new ArrayList<>()).add(signature);
        }
        
        return rGroups;
    }
    
    /**
     * Detects all reused R values in a list of signatures
     * @param signatures List of transaction signatures
     * @return List of R values that appear more than once
     */
    public List<BigInteger> detectReusedRValues(List<TransactionSignature> signatures) {
        Map<BigInteger, List<TransactionSignature>> rGroups = groupSignaturesByR(signatures);
        
        return rGroups.entrySet().stream()
            .filter(entry -> entry.getValue().size() > 1)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }
    
    /**
     * Analyzes a transaction for nonce reuse vulnerabilities
     * @param transaction The transaction to analyze
     * @return VulnerabilityReport containing analysis results
     */
    public VulnerabilityReport analyzeTransaction(BitcoinTransaction transaction) {
        if (transaction == null) {
            throw new IllegalArgumentException("Transaction cannot be null");
        }
        
        VulnerabilityReport report = new VulnerabilityReport();
        report.setTransactionId(transaction.getTransactionId());
        report.setTotalSignatures(transaction.getSignatureCount());
        
        List<TransactionSignature> signatures = transaction.getSignatures();
        
        if (signatures.isEmpty()) {
            report.setVulnerable(false);
            report.addMessage("No signatures found in transaction");
            return report;
        }
        
        if (signatures.size() == 1) {
            report.setVulnerable(false);
            report.addMessage("Single signature transaction - no vulnerability possible");
            return report;
        }
        
        // Group signatures by R value
        Map<BigInteger, List<TransactionSignature>> rGroups = groupSignaturesByR(signatures);
        
        // Find reused R values
        List<BigInteger> reusedRValues = rGroups.entrySet().stream()
            .filter(entry -> entry.getValue().size() > 1)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
        
        report.setReusedRValues(reusedRValues);
        report.setUniqueRCount(rGroups.size());
        
        if (reusedRValues.isEmpty()) {
            report.setVulnerable(false);
            report.addMessage("No R value reuse detected - transaction appears secure");
        } else {
            report.setVulnerable(true);
            report.addMessage(String.format("Vulnerability detected! Found %d reused R value(s)", reusedRValues.size()));
            
            // Analyze each reused R value
            for (BigInteger rValue : reusedRValues) {
                List<TransactionSignature> sameRSignatures = rGroups.get(rValue);
                VulnerabilityReport.ReuseInstance instance = new VulnerabilityReport.ReuseInstance();
                instance.setRValue(rValue);
                instance.setAffectedSignatures(sameRSignatures);
                instance.setPossibleKeyPairs(calculatePossiblePairs(sameRSignatures.size()));
                
                report.addReuseInstance(instance);
            }
        }
        
        return report;
    }
    
    /**
     * Calculates the number of possible signature pairs for a given count
     * @param signatureCount Number of signatures with the same R value
     * @return Number of possible pairs (combinations)
     */
    private int calculatePossiblePairs(int signatureCount) {
        if (signatureCount < 2) return 0;
        return signatureCount * (signatureCount - 1) / 2;
    }
    
    /**
     * Validates that two signatures can be used for the attack
     * @param sig1 First signature
     * @param sig2 Second signature
     * @return ValidationResult indicating if the pair is valid for attack
     */
    public ValidationResult validateSignaturePair(TransactionSignature sig1, TransactionSignature sig2) {
        if (sig1 == null || sig2 == null) {
            return new ValidationResult(false, "One or both signatures are null");
        }
        
        if (!sig1.getR().equals(sig2.getR())) {
            return new ValidationResult(false, "Signatures do not have the same R value");
        }
        
        if (sig1.getS().equals(sig2.getS())) {
            return new ValidationResult(false, "Signatures have the same S value - attack not possible");
        }
        
        if (sig1.getMessageHash().equals(sig2.getMessageHash())) {
            return new ValidationResult(false, "Signatures have the same message hash - attack not meaningful");
        }
        
        // Check if values are within reasonable range (allowing for educational examples)
        BigInteger curveOrder = ECDSAAttack.CURVE_ORDER;
        BigInteger maxAllowed = curveOrder.multiply(BigInteger.valueOf(10));
        
        if (sig1.getR().compareTo(maxAllowed) >= 0 || sig2.getR().compareTo(maxAllowed) >= 0) {
            return new ValidationResult(false, "R value is unreasonably large");
        }
        
        if (sig1.getS().compareTo(maxAllowed) >= 0 || sig2.getS().compareTo(maxAllowed) >= 0) {
            return new ValidationResult(false, "S value is unreasonably large");
        }
        
        return new ValidationResult(true, "Signature pair is valid for attack");
    }
    
    /**
     * Finds all valid signature pairs for attack in a transaction
     * @param transaction The transaction to analyze
     * @return List of signature pairs that can be used for key recovery
     */
    public List<SignaturePair> findAttackablePairs(BitcoinTransaction transaction) {
        List<SignaturePair> attackablePairs = new ArrayList<>();
        
        Map<BigInteger, List<TransactionSignature>> rGroups = groupSignaturesByR(transaction.getSignatures());
        
        // Check each group with reused R values
        for (Map.Entry<BigInteger, List<TransactionSignature>> entry : rGroups.entrySet()) {
            List<TransactionSignature> signatures = entry.getValue();
            
            if (signatures.size() < 2) continue;
            
            // Generate all pairs within this R group
            for (int i = 0; i < signatures.size(); i++) {
                for (int j = i + 1; j < signatures.size(); j++) {
                    TransactionSignature sig1 = signatures.get(i);
                    TransactionSignature sig2 = signatures.get(j);
                    
                    ValidationResult validation = validateSignaturePair(sig1, sig2);
                    if (validation.isValid()) {
                        attackablePairs.add(new SignaturePair(sig1, sig2, entry.getKey()));
                    }
                }
            }
        }
        
        return attackablePairs;
    }
    
    /**
     * Result class for vulnerability analysis
     */
    public static class VulnerabilityReport {
        private String transactionId;
        private boolean vulnerable;
        private int totalSignatures;
        private int uniqueRCount;
        private List<BigInteger> reusedRValues;
        private List<ReuseInstance> reuseInstances;
        private List<String> messages;
        
        public VulnerabilityReport() {
            this.reusedRValues = new ArrayList<>();
            this.reuseInstances = new ArrayList<>();
            this.messages = new ArrayList<>();
        }
        
        // Getters and setters
        public String getTransactionId() { return transactionId; }
        public void setTransactionId(String transactionId) { this.transactionId = transactionId; }
        
        public boolean isVulnerable() { return vulnerable; }
        public void setVulnerable(boolean vulnerable) { this.vulnerable = vulnerable; }
        
        public int getTotalSignatures() { return totalSignatures; }
        public void setTotalSignatures(int totalSignatures) { this.totalSignatures = totalSignatures; }
        
        public int getUniqueRCount() { return uniqueRCount; }
        public void setUniqueRCount(int uniqueRCount) { this.uniqueRCount = uniqueRCount; }
        
        public List<BigInteger> getReusedRValues() { return reusedRValues; }
        public void setReusedRValues(List<BigInteger> reusedRValues) { this.reusedRValues = reusedRValues; }
        
        public List<ReuseInstance> getReuseInstances() { return reuseInstances; }
        public void addReuseInstance(ReuseInstance instance) { this.reuseInstances.add(instance); }
        
        public List<String> getMessages() { return messages; }
        public void addMessage(String message) { this.messages.add(message); }
        
        @Override
        public String toString() {
            return String.format("VulnerabilityReport{tx=%s, vulnerable=%s, signatures=%d, reusedR=%d}",
                transactionId, vulnerable, totalSignatures, reusedRValues.size());
        }
        
        /**
         * Inner class representing a specific R value reuse instance
         */
        public static class ReuseInstance {
            private BigInteger rValue;
            private List<TransactionSignature> affectedSignatures;
            private int possibleKeyPairs;
            
            public ReuseInstance() {
                this.affectedSignatures = new ArrayList<>();
            }
            
            // Getters and setters
            public BigInteger getRValue() { return rValue; }
            public void setRValue(BigInteger rValue) { this.rValue = rValue; }
            
            public List<TransactionSignature> getAffectedSignatures() { return affectedSignatures; }
            public void setAffectedSignatures(List<TransactionSignature> affectedSignatures) { 
                this.affectedSignatures = affectedSignatures; 
            }
            
            public int getPossibleKeyPairs() { return possibleKeyPairs; }
            public void setPossibleKeyPairs(int possibleKeyPairs) { this.possibleKeyPairs = possibleKeyPairs; }
        }
    }
    
    /**
     * Result class for signature pair validation
     */
    public static class ValidationResult {
        private boolean valid;
        private String message;
        
        public ValidationResult(boolean valid, String message) {
            this.valid = valid;
            this.message = message;
        }
        
        public boolean isValid() { return valid; }
        public String getMessage() { return message; }
        
        @Override
        public String toString() {
            return String.format("ValidationResult{valid=%s, message='%s'}", valid, message);
        }
    }
    
    /**
     * Class representing a pair of signatures that can be used for attack
     */
    public static class SignaturePair {
        private TransactionSignature signature1;
        private TransactionSignature signature2;
        private BigInteger sharedRValue;
        
        public SignaturePair(TransactionSignature signature1, TransactionSignature signature2, BigInteger sharedRValue) {
            this.signature1 = signature1;
            this.signature2 = signature2;
            this.sharedRValue = sharedRValue;
        }
        
        public TransactionSignature getSignature1() { return signature1; }
        public TransactionSignature getSignature2() { return signature2; }
        public BigInteger getSharedRValue() { return sharedRValue; }
        
        @Override
        public String toString() {
            return String.format("SignaturePair{inputs=(%d,%d), R=%s}", 
                signature1.getInputIndex(), signature2.getInputIndex(), 
                sharedRValue.toString(16).substring(0, 16) + "...");
        }
    }
}
